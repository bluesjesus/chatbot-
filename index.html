<script type="module">
    // --- Firebase SDK Imports ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-analytics.js"; // Included as per your config
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js"; // Updated to 11.9.1
    import { getFirestore, doc, getDoc, setDoc, addDoc, updateDoc, deleteDoc, onSnapshot, collection, query, serverTimestamp, getDocs } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js"; // Updated to 11.9.1

    // --- Your Firebase Configuration ---
    const firebaseConfig = {
      apiKey: "AIzaSyDDdaUMgPSmlkRfjaBDm9SrylWyX7wC2oE",
      authDomain: "ai-chatbot-b38da.firebaseapp.com",
      projectId: "ai-chatbot-b38da",
      storageBucket: "ai-chatbot-b38da.firebasestorage.app",
      messagingSenderId: "502343320611",
      appId: "1:502343320611:web:247b096133faf46688dd96",
      measurementId: "G-C41SD3CCJ2"
    };

    // --- Initialize Firebase ---
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app); // Initialized as per your config
    const auth = getAuth(app); // Initialize Auth
    const db = getFirestore(app); // Initialize Firestore


    // --- App State & Firebase (variables only, initialization moved above) ---
    let userId = null;
    let currentChatId = null;
    let chats = [];
    let userName = 'User';
    let uploadedImageBase64 = null;
    let uploadedImageMimeType = null;
    let unsubscribeChats = () => {};
    let unsubscribeMessages = () => {};
    let isTyping = false;
    let deleteChatConfirmedId = null;

    // --- Touch Swipe Variables ---
    let touchStartX = 0;
    let touchStartY = 0;
    let touchCurrentX = 0;
    let touchCurrentY = 0;
    let isSwiping = false;
    const SWIPE_THRESHOLD = 50;
    const TRIGGER_ZONE_WIDTH = 40; // Area from left edge to start swipe-to-open

    // --- Data Management (Firestore) ---
    async function loadUserProfile() {
        if (!userId) return;
        const userDocRef = doc(db, `artifacts/${app.options.appId}/users/${userId}/profile/info`); // Use app.options.appId
        const docSnap = await getDoc(userDocRef);

        if (docSnap.exists()) {
            userName = docSnap.data().name || 'User';
        } else {
            await setDoc(userDocRef, { name: 'User' });
            userName = 'User';
        }
    }

    async function saveUserProfile(newName) {
        userName = newName;
        if (!userId) return;
        const userDocRef = doc(db, `artifacts/${app.options.appId}/users/${userId}/profile/info`); // Use app.options.appId
        await setDoc(userDocRef, { name: userName });
        renderUserProfile();
    }

    function setupChatListener() {
        unsubscribeChats();
        if (!userId) return;

        const chatsCollectionRef = collection(db, `artifacts/${app.options.appId}/users/${userId}/chats`); // Use app.options.appId
        const q = query(chatsCollectionRef);

        unsubscribeChats = onSnapshot(q, (snapshot) => {
            chats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            chats.sort((a, b) => (b.updatedAt?.toMillis() || 0) - (a.updatedAt?.toMillis() || 0));

            if (!currentChatId || !chats.some(c => c.id === currentChatId)) {
                currentChatId = chats.length > 0 ? chats[0].id : null;
            }
            renderChatHistory();
            renderChatMessages();
        }, (error) => {
            console.error("Error listening to chat history:", error);
        });
    }

    function setupMessagesListener() {
        unsubscribeMessages();
        if (!userId || !currentChatId) {
            renderWelcomeMessage();
            return;
        }

        const messagesCollectionRef = collection(db, `artifacts/${app.options.appId}/users/${userId}/chats/${currentChatId}/messages`); // Use app.options.appId
        const q = query(messagesCollectionRef);

        unsubscribeMessages = onSnapshot(q, (snapshot) => {
            const messages = snapshot.docs.map(doc => doc.data());
            messages.sort((a, b) => (a.timestamp?.toMillis() || 0) - (b.timestamp?.toMillis() || 0));
            renderMessagesToUI(messages);
        }, (error) => {
            console.error("Error listening to messages:", error);
        });
    }

    // --- Rendering Functions ---
    function renderUserProfile() {
        userNameEl.textContent = userName;
        userIdDisplay.textContent = `ID: ${userId ? userId.substring(0, 8) + '...' : 'N/A'}`;
        avatarEl.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(userName)}&background=random&color=fff&size=32`;
        profileNameInput.value = userName;
    }

    function renderWelcomeMessage() {
        chatArea.innerHTML = `
            <div class="welcome-message">
                <h1>Welcome to AI Assistant</h1>
                <p>Start a new chat or select an existing one from the sidebar.</p>
            </div>
        `;
        headerTitle.textContent = "New Chat";
        chatInput.value = '';
        chatInput.style.height = 'auto';
        sendBtn.disabled = true;
        hideImagePreview();
    }

    function renderChatMessages() {
        if (!currentChatId) {
            renderWelcomeMessage();
            return;
        }
        chatArea.innerHTML = `<div class="welcome-message"><p>Loading chat...</p></div>`;
        const selectedChat = chats.find(chat => chat.id === currentChatId);
        headerTitle.textContent = selectedChat ? selectedChat.title : "Chat";
        setupMessagesListener();
    }

    function renderMessagesToUI(messages) {
        chatArea.innerHTML = '';
        messages.forEach(msg => {
            addMessageToChat(msg.text, msg.sender, msg.sentImage, false);
        });
        scrollToBottom();
    }

    /**
     * Converts basic Markdown (like **bold** and *italic*) to HTML.
     * @param {string} markdownText The text containing Markdown.
     * @returns {string} The HTML string.
     */
    function convertMarkdownToHtml(markdownText) {
        let htmlText = markdownText;
        // Process bold first: **text** to <strong>text</strong>
        htmlText = htmlText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        // Then process italics: *text* to <em>text</em>
        htmlText = htmlText.replace(/\*(.*?)\*/g, '<em>$1</em>');
        // Convert newlines to break tags for simple formatting
        htmlText = htmlText.replace(/\n/g, '<br>');
        return htmlText;
    }

    /**
     * Adds a message to the chat display.
     * @param {string} text The message text.
     * @param {'user'|'bot'} sender The sender of the message.
     * @param {string|null} sentImage Base64 image data URL if user sent an image.
     * @param {boolean} [shouldAnimate=true] Whether to animate the text appearance (only for bot messages).
     */
    function addMessageToChat(text, sender, sentImage = null, shouldAnimate = true) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', sender);

        const avatarInitial = sender === 'user' ? userName.charAt(0).toUpperCase() : 'AI';
        const avatarColor = sender === 'user' ? '#007bff' : '#6c757d';
        const messageAvatar = document.createElement('div');
        messageAvatar.classList.add('message-avatar');
        messageAvatar.textContent = avatarInitial;
        messageAvatar.style.backgroundColor = avatarColor;

        const messageContentDiv = document.createElement('div');
        messageContentDiv.classList.add('message-content');

        const messageTextEl = document.createElement('p');
        messageContentDiv.appendChild(messageTextEl);

        if (sentImage && sender === 'user') {
            const imgEl = document.createElement('img');
            imgEl.src = sentImage;
            imgEl.classList.add('sent-image');
            messageContentDiv.appendChild(imgEl);
        }

        messageDiv.appendChild(messageAvatar);
        messageDiv.appendChild(messageContentDiv);
        chatArea.appendChild(messageDiv);

        const processedText = convertMarkdownToHtml(text);

        if (sender === 'bot' && shouldAnimate) {
            animateText(messageTextEl, processedText);
        } else {
            messageTextEl.innerHTML = processedText;
        }

        scrollToBottom();
    }

    /**
     * Animates HTML content word by word, preserving tags.
     * @param {HTMLElement} element The HTML element to write text into.
     * @param {string} htmlString The full HTML string to animate and display.
     * @param {number} [wordDelay=40] Delay in milliseconds per word/token.
     */
    function animateText(element, htmlString, wordDelay = 40) {
        element.innerHTML = '';
        let currentHtml = '';
        let currentTokenIndex = 0;

        const tokens = htmlString.split(/(<[^>]+>|\s+)/).filter(token => token.length > 0);

        const interval = setInterval(() => {
            if (currentTokenIndex < tokens.length) {
                const token = tokens[currentTokenIndex];
                currentHtml += token;
                element.innerHTML = currentHtml;
                currentTokenIndex++;
                scrollToBottom();
            } else {
                clearInterval(interval);
                element.innerHTML = htmlString;
                scrollToBottom();
            }
        }, wordDelay);
    }

    function scrollToBottom() {
        chatArea.scrollTop = chatArea.scrollHeight;
    }

    function showTypingIndicator() {
        if (isTyping) return;
        isTyping = true;
        const indicator = document.createElement('div');
        indicator.classList.add('typing-indicator');
        indicator.innerHTML = `<div class="message-avatar" style="background-color: #6c757d;">AI</div> <span></span><span></span><span></span>`;
        chatArea.appendChild(indicator);
        scrollToBottom();
    }

    function hideTypingIndicator() {
        isTyping = false;
        const indicator = document.querySelector('.typing-indicator');
        if (indicator) {
            indicator.remove();
        }
    }

    function showSettingsModal() {
        profileNameInput.value = userName;
        settingsModal.classList.add('show');
    }

    function hideSettingsModal() {
        settingsModal.classList.remove('show');
    }

    function showConfirmDeleteModal(chatId) {
        deleteChatConfirmedId = chatId;
        confirmDeleteModal.classList.add('show');
    }

    function hideConfirmDeleteModal() {
        confirmDeleteModal.classList.remove('show');
        deleteChatConfirmedId = null;
    }

    function showImagePreview(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            imagePreview.src = e.target.result;
            uploadedImageBase64 = e.target.result.split(',')[1];
            uploadedImageMimeType = file.type;
            imageNameEl.textContent = file.name;
            imagePreviewContainer.style.display = 'flex';
        };
        reader.readAsDataURL(file);
    }

    function hideImagePreview() {
        imagePreview.src = '';
        uploadedImageBase64 = null;
        uploadedImageMimeType = null;
        imageNameEl.textContent = '';
        imageInput.value = '';
    }

    // --- Chat Logic ---
    async function startNewChat() {
        currentChatId = null;
        unsubscribeMessages();
        renderWelcomeMessage();
        sidebar.classList.remove('open');
        sidebarOverlay.classList.remove('active');
    }

    async function selectChat(chatId) {
        if (currentChatId === chatId) {
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('active');
            }
            return;
        }
        currentChatId = chatId;
        renderChatHistory();
        setupMessagesListener();
        sidebar.classList.remove('open');
        sidebarOverlay.classList.remove('active');
    }

    async function sendMessage(event) {
        event.preventDefault();

        const inputText = chatInput.value.trim();
        const hasImage = uploadedImageBase64 !== null && uploadedImageMimeType !== null;

        if (!inputText && !hasImage) {
            return;
        }

        sendBtn.disabled = true;
        chatInput.value = '';
        chatInput.style.height = 'auto';
        hideImagePreview();

        let messageText = inputText;
        let sentImage = uploadedImageBase64 ? `data:${uploadedImageMimeType};base64,${uploadedImageBase64}` : null;

        try {
            if (!currentChatId) {
                const newChatRef = await addDoc(collection(db, `artifacts/${app.options.appId}/users/${userId}/chats`), { // Use app.options.appId
                    title: inputText.substring(0, 50) + (inputText.length > 50 ? '...' : ''),
                    createdAt: serverTimestamp(),
                    updatedAt: serverTimestamp(),
                });
                currentChatId = newChatRef.id;
                renderChatHistory();
                selectChat(currentChatId);
            } else {
                const chatDocRef = doc(db, `artifacts/${app.options.appId}/users/${userId}/chats/${currentChatId}`); // Use app.options.appId
                await updateDoc(chatDocRef, { updatedAt: serverTimestamp() });
            }

            await addDoc(collection(db, `artifacts/${app.options.appId}/users/${userId}/chats/${currentChatId}/messages`), { // Use app.options.appId
                text: messageText,
                sender: 'user',
                timestamp: serverTimestamp(),
                sentImage: sentImage,
            });

            showTypingIndicator();

            // Call the backend API (either Render or your local Node.js server)
            // You'll need to uncomment and use the appropriate URL here
             await callGeminiAPI(messageText, uploadedImageBase64, uploadedImageMimeType);

        } catch (error) {
            console.error("Error sending message or calling API:", error);
             addMessageToChat("Error: Could not send message or get response. Please try again.", 'bot', null, true);
        } finally {
            hideTypingIndicator();
            sendBtn.disabled = false;
        }
    }

    // This function now calls your backend (either Render or local Node.js)
     async function callGeminiAPI(prompt, imageBase64 = null, imageMimeType = null) {
         // Choose the correct API URL:
         // If using your local Node.js server:
          const apiUrl = "http://localhost:3000/api/gemini-chat";
         // If using your Render backend:
         // const apiUrl = "https://chatbot-flash.onrender.com/api/gemini-chat";


         const messagesCollectionRef = collection(db, `artifacts/${app.options.appId}/users/${userId}/chats/${currentChatId}/messages`); // Use app.options.appId
         const snapshot = await getDocs(messagesCollectionRef);
         const currentMessages = snapshot.docs.map(doc => doc.data());
         currentMessages.sort((a, b) => (a.timestamp?.toMillis() || 0) - (b.timestamp?.toMillis() || 0));

         let chatHistory = [];
         currentMessages.forEach(msg => {
             if (msg.sender === 'user') {
                 const userParts = [{ text: msg.text }];
                 if (msg.sentImage) {
                     const parts = msg.sentImage.split(';base64,');
                     if (parts.length === 2) {
                         const mime = parts[0].substring(5);
                         const data = parts[1];
                         userParts.push({ inlineData: { mimeType: mime, data: data } });
                     }
                 }
                 chatHistory.push({ role: "user", parts: userParts });
             } else if (msg.sender === 'bot') {
                 chatHistory.push({ role: "model", parts: [{ text: msg.text }] });
             }
         });

         const userPartsForCurrentPrompt = [{ text: prompt }];
         if (imageBase64 && imageMimeType) {
             userPartsForCurrentPrompt.push({ inlineData: { mimeType: imageMimeType, data: imageBase64 } });
         }
         chatHistory.push({ role: "user", parts: userPartsForCurrentPrompt });


         const payload = { contents: chatHistory };

         try {
             const response = await fetch(apiUrl, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(payload)
             });

             if (!response.ok) {
                 const errorData = await response.json();
                 console.error("Gemini API error response:", errorData);
                 throw new Error(`API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
             }

             const result = await response.json();

             let botResponseText = "No response from AI.";
             if (result.candidates && result.candidates.length > 0 &&
                 result.candidates[0].content && result.candidates[0].content.parts &&
                 result.candidates[0].content.parts.length > 0) {
                 botResponseText = result.candidates[0].content.parts[0].text;
             }

             await addDoc(collection(db, `artifacts/${app.options.appId}/users/${userId}/chats/${currentChatId}/messages`), { // Use app.options.appId
                 text: botResponseText,
                 sender: 'bot',
                 timestamp: serverTimestamp(),
             });

         } catch (error) {
             console.error("Error communicating with backend API:", error); // Changed log message
             await addDoc(collection(db, `artifacts/${app.options.appId}/users/${userId}/chats/${currentChatId}/messages`), { // Use app.options.appId
                 text: `Error: Failed to get a response from the AI. (${error.message})`,
                 sender: 'bot',
                 timestamp: serverTimestamp(),
             });
         }
     }


    async function deleteChat(chatIdToDelete) {
        if (!userId || !chatIdToDelete) return;
        const appId = app.options.appId; // Use app.options.appId

        try {
            const messagesCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/chats/${chatIdToDelete}/messages`);
            const snapshot = await getDocs(messagesCollectionRef);
            const deletePromises = [];
            snapshot.forEach(msgDoc => {
                deletePromises.push(deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/chats/${chatIdToDelete}/messages`, msgDoc.id)));
            });
            await Promise.all(deletePromises);
            console.log("All messages deleted for chat:", chatIdToDelete);

            await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/chats/${chatIdToDelete}`));
            console.log("Chat document deleted:", chatIdToDelete);

            hideConfirmDeleteModal();
        } catch (error) {
            console.error("Error deleting chat:", error);
        }
    }


    // --- Event Listeners ---
    menuBtn.addEventListener('click', () => {
        sidebar.classList.toggle('open');
        sidebarOverlay.classList.toggle('active');
    });

    sidebarOverlay.addEventListener('click', () => {
        sidebar.classList.remove('open');
        sidebarOverlay.classList.remove('active');
    });

    newChatBtn.addEventListener('click', startNewChat);
    mainPanelNewChatBtn.addEventListener('click', startNewChat);

    chatForm.addEventListener('submit', sendMessage);

    chatInput.addEventListener('input', () => {
        chatInput.style.height = 'auto';
        chatInput.style.height = chatInput.scrollHeight + 'px';
        sendBtn.disabled = chatInput.value.trim() === '' && uploadedImageB
